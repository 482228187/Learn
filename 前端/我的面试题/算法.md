# 九、算法：

## 1.[排序方法](https://juejin.cn/post/7073640285904830471)

### 冒泡排序：

在每次冒泡操作时会比较相邻的两个元素，看是否满足大小关系要求，不满足就将它俩互换。一直迭代到不再需要交换，也就是排序完成。

```
/**
 * 外循环控制需要比较的元素，比如第一次排序后，
最后一个元素就不需要比较了，内循环则负责两两元素比较，将元素放到正确位置上
*/
function bubbleSort(arr) {
    const len = arr.length
    for(let i=0; i<len; i++) {
        for(let j=0;j<len-1-i; j++) {
          // 注意边界值
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]] // 交换位置
            }
        }
    }
    return arr
}

console.log(bubbleSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,3,4,15,19,26,27,36,44,46,48,50]

```

- 时间复杂度: O(n^2)
- 空间复杂度: O(1) 

![bubblesort.gif](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/a0250d86fac644ea82f323a990e1aed5-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 选择排序

**时间复杂度O(n^2)** 

首先在待排序序列中选出最小或最大值，存放在排序序列起始位置，然后再从剩余未排序元素中继续寻找最小或最大元素，放到已排序序列末尾。以此类推，直到所有元素均排序完毕。 

```
/**
 * 先假设第一个元素为最小的，然后通过循环找出最小元素，
 * 然后同第一个元素交换，接着假设第二个元素，重复上述操作即可
 */

function selectSort(arr) {
    let len = arr.length, minIndex, tem
    for(let i=0; i<len-1; i++) {
        minIndex = i //最小值下标
        for(let j=i+1; j<len; j++) {
            if(arr[j] < arr[minIndex]){
                // 找出最小值
                minIndex = j //更换最小值下标
            }
        }
        // 交换位置
        tem = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = tem
    }
    return arr
}

console.log(selectSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]

```

![selectionsort.gif](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/7a287f44039844f694bbf67069ee3d66-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 快速排序

**时间复杂度：O(nlogn)** 

- 选择一个参考元素，将列表分割成两个子序列；
- 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；
- 分别对较小元素的子序列和较大元素的子序列重复步骤1和2

```
function quickSort(arr) {
    if(arr.length<=1) return arr
    const left = [],right = [],current = arr.splice(0,1)
    for(let i=0; i<arr.length; i++) {
        if(arr[i]<current) {
            // 小于参考值放左边
            left.push(arr[i]) 
        }else{
            // 否则放右边
            right.push(arr[i])
        }
    }
    //递归上述步骤
    return quickSort(left).concat(current,quickSort(right))
}

console.log(quickSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]
```



![image.png](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/9bbcf3482cec45b894ce9383f9cd9bd6-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 插入排序

对于未排序的数据，在已排序的序列中从后往前扫描，找到相应的位置进行插入，保持已排序序列中元素一直有序。 

- 时间复杂度: O(n^2)

```
const insertSort = function(arr) {
    const len = arr.length
    let curr, prev
    for (let i = 1; i < len; i++) {
        curr = arr[i]
        prev = i - 1
        while (prev >= 0 && arr[prev] > curr) {
            arr[prev + 1] = arr[prev]
            prev--
        }
        arr[prev + 1] = curr
    }
    return arr
}
```



![img](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/d5ae17e6956f478fa3ec261621cdeee9-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.awebp) 

### 归并排序

将若干有序序列逐步归并，最终归并为一个有序序列。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是`O(n log n）`的时间复杂度。 

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

```
// 将数组一直等分，然后合并
function merge(left, right) {
    let tem = []
    while(left.length && right.length) {
        if(left[0] < right[0]) {
            tem.push(left.shift())
        }else{
            tem.push(right.shift())
        }
    }
    return tem.concat(left,right)
}
function mergeSort(arr) {
    const len = arr.length
    if(len<2) return arr
    let mid = Math.floor(len / 2), left = arr.slice(0,mid), right = arr.slice(mid)
    return merge(mergeSort(left),mergeSort(right))
}
console.log(mergeSort([3,44,15,36,26,27,2,46,4,19,50,48]))
// [2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]

```

![image.png](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/78029fcda4ef48f58de7a0fe05e1d75b-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

