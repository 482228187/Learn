# 九、算法：

## 1.[排序方法](https://juejin.cn/post/7073640285904830471)

### 冒泡排序：

在每次冒泡操作时会比较相邻的两个元素，看是否满足大小关系要求，不满足就将它俩互换。一直迭代到不再需要交换，也就是排序完成。

```
/**
 * 外循环控制需要比较的元素，比如第一次排序后，
最后一个元素就不需要比较了，内循环则负责两两元素比较，将元素放到正确位置上
*/
function bubbleSort(arr) {
    const len = arr.length
    for(let i=0; i<len; i++) {
        for(let j=0;j<len-1-i; j++) {
          // 注意边界值
            if(arr[j] > arr[j+1]){
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]] // 交换位置
            }
        }
    }
    return arr
}

console.log(bubbleSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,3,4,15,19,26,27,36,44,46,48,50]

```

- 时间复杂度: O(n^2)
- 空间复杂度: O(1) 

![bubblesort.gif](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/a0250d86fac644ea82f323a990e1aed5-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 选择排序

**时间复杂度O(n^2)** 

首先在待排序序列中选出最小或最大值，存放在排序序列起始位置，然后再从剩余未排序元素中继续寻找最小或最大元素，放到已排序序列末尾。以此类推，直到所有元素均排序完毕。 

```
/**
 * 先假设第一个元素为最小的，然后通过循环找出最小元素，
 * 然后同第一个元素交换，接着假设第二个元素，重复上述操作即可
 */

function selectSort(arr) {
    let len = arr.length, minIndex, tem
    for(let i=0; i<len-1; i++) {
        minIndex = i //最小值下标
        for(let j=i+1; j<len; j++) {
            if(arr[j] < arr[minIndex]){
                // 找出最小值
                minIndex = j //更换最小值下标
            }
        }
        // 交换位置
        tem = arr[i]
        arr[i] = arr[minIndex]
        arr[minIndex] = tem
    }
    return arr
}

console.log(selectSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]

```

![selectionsort.gif](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/7a287f44039844f694bbf67069ee3d66-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 快速排序

**时间复杂度：O(nlogn)** 

- 选择一个参考元素，将列表分割成两个子序列；
- 对列表重新排序，将所有小于基准值的元素放在基准值前面，所有大于基准值的元素放在基准值的后面；
- 分别对较小元素的子序列和较大元素的子序列重复步骤1和2

```
function quickSort(arr) {
    if(arr.length<=1) return arr
    const left = [],right = [],current = arr.splice(0,1)
    for(let i=0; i<arr.length; i++) {
        if(arr[i]<current) {
            // 小于参考值放左边
            left.push(arr[i]) 
        }else{
            // 否则放右边
            right.push(arr[i])
        }
    }
    //递归上述步骤
    return quickSort(left).concat(current,quickSort(right))
}

console.log(quickSort([3,44,15,36,26,27,2,46,4,19,50,48]))
//[2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]
```



![image.png](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/9bbcf3482cec45b894ce9383f9cd9bd6-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

### 插入排序

对于未排序的数据，在已排序的序列中从后往前扫描，找到相应的位置进行插入，保持已排序序列中元素一直有序。 

- 时间复杂度: O(n^2)

```
const insertSort = function(arr) {
    const len = arr.length
    let curr, prev
    for (let i = 1; i < len; i++) {
        curr = arr[i]
        prev = i - 1
        while (prev >= 0 && arr[prev] > curr) {
            arr[prev + 1] = arr[prev]
            prev--
        }
        arr[prev + 1] = curr
    }
    return arr
}
```



![img](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/d5ae17e6956f478fa3ec261621cdeee9-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.awebp) 

### 归并排序

将若干有序序列逐步归并，最终归并为一个有序序列。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是`O(n log n）`的时间复杂度。 

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

```
// 将数组一直等分，然后合并
function merge(left, right) {
    let tem = []
    while(left.length && right.length) {
        if(left[0] < right[0]) {
            tem.push(left.shift())
        }else{
            tem.push(right.shift())
        }
    }
    return tem.concat(left,right)
}
function mergeSort(arr) {
    const len = arr.length
    if(len<2) return arr
    let mid = Math.floor(len / 2), left = arr.slice(0,mid), right = arr.slice(mid)
    return merge(mergeSort(left),mergeSort(right))
}
console.log(mergeSort([3,44,15,36,26,27,2,46,4,19,50,48]))
// [2,  3,  4, 15, 19, 26, 27, 36, 44, 46, 48, 50]

```

![image.png](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/78029fcda4ef48f58de7a0fe05e1d75b-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.webp) 

## 最长公共子前缀

```
var longestCommonPrefix = function(strs) {
    var re = strs[0] ? strs[0]:'';
    for (var i=1;i<strs.length;i++){
        var regex = new RegExp('^'+re);
        while (!regex.test(strs[i])&&re.length){
            re = re.slice(0,re.length-1);
            regex = new RegExp('^'+re);
        }
    }
    return re;
};
 
链接：https://leetcode.cn/problems/longest-common-prefix/solutions/19106/javascript-zui-chang-gong-gong-qian-zhui-by-rhinoc/ 
```

## [矩形重叠](https://leetcode.cn/problems/rectangle-overlap/)  

**两个互相重叠的矩形，它们在 x轴和 y 轴上投影出的区间也是互相重叠的**。 如果

```
def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
    x_overlap = not(rec1[2] <= rec2[0] or rec2[2] <= rec1[0])
    y_overlap = not(rec1[3] <= rec2[1] or rec2[3] <= rec1[1])
    return x_overlap and y_overlap

作者：nettee
链接：https://leetcode.cn/problems/rectangle-overlap/solutions/155825/tu-jie-jiang-ju-xing-zhong-die-wen-ti-zhuan-hua-we/ 
```

```
var isRectangleOverlap = function(rec1, rec2) {
    const [x1, y1, x2, y2] = rec1;
    const [x3, y3, x4, y4] = rec2;
    return !(x1 >= x4 || x3 >= x2 || y3 >= y2 || y1 >= y4);
};

作者：晨
链接：https://leetcode.cn/problems/rectangle-overlap/solutions/1120871/836-ju-xing-zhong-die-by-chen-wei-f-akdd/ 
```

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/) 

- 栈先入后出特点恰好与本题括号排序特点一致，即若遇到左括号入栈，遇到右括号时将对应栈顶左括号出栈，则遍历完所有括号后 `stack` 仍然为空；

```
 /**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
    var stack = [];
    for(var i=0;i<s.length;i++){
        const start = s[i];
        if(start =='('||start =='['||start =='{'){
            stack.push(start);
        }else{
            //end是在栈里边的一个，start是还未入栈的，所以end在前，start在后
            const end = stack[stack.length-1];
            if((end=='('&&start==')')||
            (end=='['&&start==']')||
            (end=='{'&&start=='}')){
                stack.pop();
            }else{
                return false;
            }
        }
    }
    return stack.length==0;
};

作者：lotus
链接：https://leetcode.cn/problems/valid-parentheses/solutions/2747114/you-xiao-de-gua-hao-by-lotus-r3-18lj/ 
```

```
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {
	let len =s.length;
	if(len % 2 !==0 ){
		return false;
	}
 	let length = len / 2;
		for (let i = 0; i < length; i++) {
			s = s.replace("()", "");
			s = s.replace("{}", "");
			s = s.replace("[]", "");
		}

	return s.length === 0;
};

作者：Mr-Wang-Y-P
链接：https://leetcode.cn/problems/valid-parentheses/solutions/2023895/by-mr-wang-y-p-uz6a/
 
```

