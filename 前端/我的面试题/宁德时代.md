八股题：

##  1、Vue生命周期

首先 `vue2` 和 `vue3` 的生命周期是有区别的：

> Vue2 的生命周期主要是：
>
> 1. beforeCreate：创建实例之前调用，此时实例的数据观测、事件等还未初始化。
> 2. created：创建实例后调用，此时实例的数据观测、事件等已经初始化完成。
> 3. beforeMount：挂载实例之前调用，此时模板已经编译完成，但是还未挂载到DOM。
> 4. mounted：挂载实例后调用，此时实例已经挂载到DOM，可以进行DOM操作。
> 5. beforeUpdate：数据更新之前调用，此时可以进行状态的最后更改。
> 6. updated：数据更新后调用，此时DOM已经完成更新，可以进行DOM操作，但要注意避免在此期间无限制地更新状态，以免造成循环更新。
> 7. beforeDestroy：销毁实例之前调用，此时实例仍然完全可用。在这个阶段，实例仍然完全可用，适合进行一些清理工作，如清除定时器、解绑全局事件等。
> 8. Destoryed: 销毁实例后调用，此时实例已经完全卸载 ，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，事件监听器被移除，所有子实例也统统被销毁。 

而 `vue3` 在 `vue2` 的基础上进行了一些改变，主要是针对最后两个生命周期：

> beforeDestroy -> beforeUnmount
>
> Destoryed -> Unmounted

另外 `options API` 和 `composition API` 在生命周期上也有一些小的不同：

> `composition API` 提供了 `setup` 函数作为入口函数，替换了 `beforeCreate` 和 `created` 这两个生命周期钩子。
>
> 所以在实际开发中，我们可以简单的把 `setup` 理解为 `created` 进行使用。

 

##  2、Js是单线程还是多线程，为什么 

 JavaScript 是单线程的语言。这意味着 JavaScript 引擎在任何特定时间只能执行一个任务。这个任务队列被称为事件循环 (Event Loop)。 

JavaScript 之所以设计成单线程，有几个原因：

1. **简单性：** 单线程模型简化了语言和运行时环境的设计和实现。如果 JavaScript 是多线程的，开发者需要处理线程同步、锁定等复杂的问题。这不仅会增加代码的复杂性，还容易引入死锁和竞态条件等 bug。
2. **浏览器安全模型：** JavaScript 最初是为了在浏览器中运行而设计的。多线程可能会引发跨域安全问题。单线程模型可以避免多个线程同时修改同一份数据而引发的安全隐患。

 

## 3、Vue常见指令 

`v-on ` `v-if` 	` v-show`  `v-model`  ` v-bind`  `v-for`

+ v-if

将 `v-if` 指令添加到 HTML 元素中，可以根据表达式的真假条件来进行条件性渲染。

+ v-for

v-for可以基于源数据多次渲染元素或模板块。

+ v-show

v-show用于根据条件控制元素的显示与隐藏。使用 `v-show` 指令时，元素始终会被渲染到 DOM 中，只是通过修改 CSS 属性来控制元素的显示与隐藏。这与 `v-if` 指令不同，`v-if` 在条件为假时会完全从 DOM 中移除元素。而`v-show`控制的元素是一直存在的，只不过没有显示出来。它的使用方法和`v-if`是一样的，但`v-show` 只能用于普通元素，不能用于 `<template>` 标签或组件。如果需要根据条件动态地渲染组件，应该使用 `v-if` 指令。

+ v-bind

`v-bind` 用于绑定数据到 HTML 元素属性中。当你需要动态地将一个表达式的值绑定到元素的某个属性时，就可以使用 `v-bind` 或 它的简写语法`:`

+ v-on

`v-on` 是用于绑定事件监听器的指令，它可以捕获和响应 HTML 元素上触发的各种事件。它可以简写为`@`

+ v-model

`v-model` 可以将表单元素的值和 Vue 实例中的数据进行双向绑定，当表单元素的值发生变化时，对应的数据也会更新，反之亦然。

## 4、Vue请求后端接口方式 



## 5、用了什么前端状态管理库

pinia

**使用pinia**：安装 pinia ->**创建 pinia 实例** ->**将 pinia 注册到 Vue 应用中** ->**在组件中使用状态和方法** 

pinia 是用 `defineStore()` 

**pinia**传入Option对象的核心概念包括：

> state: 用来定义一些变量
> getters: 类似于计算属性
> actions：里面是一些方法，在里面可以请求接口操作

Pinia 与 Vuex 相比 

1接口更简单，代码更简洁： 

- 舍弃了 mutation，减少了很多不必要的代码。
- 可以直接对数据进行读写，直接调用 action 方法，不再需要 commit、dispatch。



##  6、VueX大概介绍下

**安装 Vuex** ->**创建 Store 实例** ->**将 Store 注册到 Vue 应用中** ->**在组件中使用状态和方法** 

**Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，响应数据或状态给Vue 组件，界面随之更新。** 

**vuex主要包括以下几个模块：**

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

##  7、组件间的信息传递

prop attr ref v-model 插槽 

##  8、页面间的信息传递

##  9、闭包问题

##  10、js避免内存泄漏方式

## 11、css盒子模型  



## 说一下vue的每一个生命周期和该周期的作用

## vue组件之间如何通信

## 组件渲染和更新说一下

## vue-router中常见的路由模式说一下

## 我们用vue开发的时候用到了什么打包工具，它是如何完成打包任务的

## vue常见性能优化方式



## 使用过vue框架是吧？

## computed和watch的区别和应用场景

## computed有缓存机制，它是如何实现的？

## keep-alive使用过吗？

## keep-alive的作用是什么，说一下你对keep-alive的理解

## 微信小程序和混合开发有接触过吗？

混合开发其实就是html中嵌入原生H5

## 反问环节（问了技术栈）

  

##   HTML：

- HTML有哪些标签？

## 浏览器：

- 浏览器从输入到显示经过了那些步骤，输入url发生了什么？
- 跨域怎么解决？

## **Vue：**

- vue的渲染过程？(没反应过来）问知不知道render函数？(答react上去了 
- Vue的生命周期？
- 页面存储状态前端怎么做？(vuex)vuex是什么？

## 前端工程化：

- 前端有哪些性能优化方式？现在不想要别人审查元素看到编写的代码应该怎么做？
- 知道哪些前端安全问题？(把各种攻击xss、crfs说了)前端怎么解决？(不会没考虑过)

 

 

 