### 闭包内存泄露问题

让不在需要的函数或者变量等于 null 



### TCP UDP

TCP是一种**面向连接**的协议，通过**三次握手过程来建立连接**，确保两端的通信是同步的。 

UDP是一种**面向数据报的协议**，**UDP发送数据之前不需要建立连接**，它直接将数据包发送给接收方，不保证数据包的顺序、完整性或可靠性。 

**TCP**：**提供高可靠性的数据传输**。由于需要进行连接管理、错误检测和恢复，以及维持连接状态，其**数据传输速度相对较慢，协议开销较大。**TCP 具有流量控制和拥塞控制机制，可以根据网络条件调整数据传输速率，避免网络拥堵。 

**UDP**：不保证数据传输的可靠性。 由于不需要建立连接，且几乎没有错误恢复机制，使得UDP的数据传输速度较快，协议开销小，效率较高。**UDP**不提供流量控制和拥塞控制机制，发送方的发送速率不会根据网络条件进行调整。



#### 适用场景

- **TCP**：适用于需要高可靠性的应用，如网页浏览、电子邮件、文件传输等。
- **UDP**：适用于对传输速度和效率要求高、可以容忍一定数据丢失的应用，如在线视频会议、实时游戏、流媒体等。

### VUEX 状态改变流程

**安装 Vuex** ->**创建 Store 实例** ->**将 Store 注册到 Vue 应用中** ->**在组件中使用状态和方法** 



**vuex主要包括以下几个模块：**

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

**Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，响应数据或状态给Vue 组件，界面随之更新。** 

### nextTick场景

**作用：** 在改变组件中属性以后，立刻拿到渲染以后的dom节点对象 

当数据变更后，Vue 会先执行同步的数据变更操作，然后将需要更新的 DOM 操作推入微任务队列或宏任务队列，等待当前执行栈清空后执行。在任务队列执行完毕后，**Vue 会触发 `nextTick` 的回调函数**，以便我们可以在 DOM 更新完成后执行相应的操作。它的底层原理是通过利用 JavaScript 的任务队列来实现的。

 [参考](https://juejin.cn/post/7266374711823171636)

 

### 主题颜色切换



### 权限菜单



### vue react区别



### 自我介绍



### 说话声音大



### 长列表优化

- ### 基本实现

  - 获取可视区域的高度

  - 获取列表项的高度

  - 计算可视区域能展示的列表项个数 =  (可视区域高度 / 列表项高度) + 2

  - 监听滚动事件，获得开始索引，为滚动的距离 / 列表项 ，获得结束索引，为开始索引 + 可视区域可展示多少个列表项 * 2 

  - 预加载（防止滚动过快，造成暂时白屏）

  - 根据开始索引和结束索引，截取数据展示在可视区域

  - 滚动节流

  - 上下空白区使用padding实现

  - 滑动到底，再次请求数据并拼接

    

 为什么要 +2 ，是因为可能最上面和最下面的元素都只展示一部分  

为什么要乘2呢，因为这样的话可以预加载出一页的数据，防止滚动过快，出现暂时白屏现象 


[参考](https://juejin.cn/post/6966179727329460232)

 



### Pinia与Vuex

**使用vuex:** 安装 Vuex   ->**创建 Store 实例** ->**将 Store 注册到 Vue 应用中** ->**在组件中使用状态和方法** 

**使用pinia**：安装 pinia ->**创建 pinia 实例** ->**将 pinia 注册到 Vue 应用中** ->**在组件中使用状态和方法** 

pinia 是用 `defineStore()` 

**pinia**传入Option对象的核心概念包括：

> state: 用来定义一些变量
> getters: 类似于计算属性
> actions：里面是一些方法，在里面可以请求接口操作

Pinia 与 Vuex 相比 

1接口更简单，代码更简洁： 

- 舍弃了 mutation，减少了很多不必要的代码。
- 可以直接对数据进行读写，直接调用 action 方法，不再需要 commit、dispatch。

2更好的 TypeScript 支持 

- Vuex 中的很多属性缺少类型支持，需要开发者自行进行模块类型的声明。
- Pinia 中的所有内容都是类型化的，尽可能地利用了 TS 的类型推断。

 

### vue优化

#### 代码层面的优化：

1.  v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 

2. computed 和 watch 区分使用场景

    computed：  是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；

    watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；

    运用场景：

   - 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；
   - 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

3. v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

4. 长列表性能优化

   Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候 组件就是纯粹的数据展示，不会有任何改变， 不需要 Vue 来劫持我们的数据， 可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了，以减少组件初始化的时间 。

5. 图片懒加载

   对于图片过多的页面，为了加速页面加载速度，在页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升， 提高了用户体验。 

6. 路由懒加载

   把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件， 

7. 

   
  

  




 [参考来源](https://juejin.cn/post/6844903913410314247)

### 计算机网络协议

### 浏览器的渲染原理、性能分析有一定程度的学习 

### 熟悉 TCP、HTTP 网络协议，了解 http 历史发展过程。 

### 对跨域的各种方案，及优缺点有一定的学习， 

### 了解 Java/Python 后端开发语言以及MySQL/Mongodb/Neo4j/Redis 数据库运用， 

### 微信小程序开发 



### eslint、prettier、stylelint、husky、commitlin、统一包管理器  作用

**eslint和prettier这俩兄弟一个保证js代码质量，一个保证代码美观

[stylelint](https://stylelint.io/)为css的lint工具。可格式化css代码，检查css语法错误与不合理的写法，指定css书写顺序等。

husky是当我们对代码进行commit操作的时候，就会执行命令，自动对代码进行格式化，然后再提交。

对于commit信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行， 可以利用**commitlint**来实现



### 菜单权限与按钮权限 如何实现

权限基本都是由后端返回 , 后端返回的角色权限中也包含按钮权限相关数据；前端拿到按钮权限数据后，可以根据页面路由去进行匹配，从而控制按钮显示与否。使用vue的 **\*自定义指令*** 方法。

具体流程：

1. 在登录后获取到按钮权限，存储下来。 
2. 自定义指令v-has,  如果该按钮权限不能用，就将这个按钮从父节点中移除
3. 将自定义指令在main.ts文件中挂载。 
4. 每个按钮元素中使用v-has="btn.User.XXXX"去判断。 

```
import pinia from '@/store'
import useUserStore from '@/store/modules/user'
const userStore = useUserStore(pinia)
export const isHasButton = (app: any) => {
  //获取对应的用户仓库
  //全局自定义指令:实现按钮的权限
  app.directive('has', {
    //代表使用这个全局自定义指令的DOM|组件挂载完毕的时候会执行一次
    mounted(el: any, options: any) {
      //自定义指令右侧的数值:如果在用户信息buttons数组当中没有
      //从DOM树上干掉
      //el就是dom元素
      //options:传入进来的值
      if (!userStore.buttons.includes(options.value)) {
        el.parentNode.removeChild(el)
      }
    },
  })
}
```



### 请求响应拦截器二次封装 



### 实现数据大屏和主题颜色切换，如暗黑模式 

##### 数据大屏

大屏适配的解决方案  

利用scale动态屏幕适配方案，来解决浏览器放大、缩小导致数据大屏变形的问题。 

**方法：**

宽度比率 = 当前网页宽度 / 设计稿宽度

高度比率 = 当前网页高度 / 设计稿高度

设计稿： 1920 * 1080

封装一个函数动态计算网页的宽高比，决定根据`宽度比率`还是`高度比率`进行缩放 ， 如果宽度比率小于高度比率，按照宽度比率缩放，返回这个缩放比率。

初始化时动态设置大屏区域的style.transform  的缩放比率，利用window.onresize监听窗口变化并设置大屏区域缩放。

```
.screen {
    position: fixed;
    width: 1920px;
    height: 1080px;
    left: 50%;
    top: 50%;
   }
```

```
// 拿到数据大屏展示内容区域的div,假设为screen
let screen = ref()
onMounted(() => {
  screen.value.style.transform = `scale(${getScale()}) translate(-50%,-50%)`
})
//定义大屏缩放比例
function getScale(w = 1920, h = 1080) {
  const ww = window.innerWidth / w
  const wh = window.innerHeight / h
  return ww < wh ? ww : wh
}
//监听视口变化
window.onresize = () => {
  screen.value.style.transform = `scale(${getScale()}) translate(-50%,-50%)`
}
```



##### 主题颜色切换

Element Plus 默认提供一套主题，也提供了相应的修改主题颜色的方法。我们要使用的时通过js来修改主题颜色 ,理由 document.documentElement获得html，通过html.style.setProperty('--el-color-primary', color.value)设置主题颜色

点击切换的回调

```
//主题颜色的设置
const setColor = () => {
  //通知js修改根节点的样式对象的属性与属性值
  const html = document.documentElement
  html.style.setProperty('--el-color-primary', color.value)
}
```



##### 暗黑模式设置

element-plus 官方支持暗黑模式，只需要在HTML上添加一个名为dark的类，然后在项目入口文件引入样式

//<u>首先引入暗黑模式需要的样式</u>

import 'element-plus/theme-chalk/dark/css-vars.css'

<u>然后给对应的按钮绑定事件，首先 获取HTML根节点，需要设置暗黑模式，则设置html.className = 'dark'</u>

```
let dark = ref<boolean>(false)

//switch开关的chang

const changeDark = () => {

  //获取HTML根节点

  let html = document.documentElement

  //判断HTML标签是否有类名dark

  dark.value ? (html.className = 'dark') : (html.className = '')

}

```



### 导入问卷怎么实现的



### 如何给问卷添加水印



### 问卷可以进行图表分析 



### 移动端适配 怎么实现



### 多种方式登录 

https://juejin.cn/post/7172026468535369735

https://juejin.cn/post/7325645956253892608

### 校验、避免重复提交

