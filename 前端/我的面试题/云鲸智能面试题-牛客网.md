## 实习收获最大的是什么

## 地址栏输入一个url到页面渲染的全过程

![img](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/16f080b095268038-tplv-t2oaga2asx-zoom-in-crop-mark-1512-0-0-0.awebp)

![img](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/%E6%88%91%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/assets/a4a81aa9ace940ccb3642d8827aaace8-tplv-k3u1fbpfcp-zoom-in-crop-mark-1512-0-0-0.awebp) 

[图来源](https://juejin.cn/post/6898518950154338317)

- 解析HTML：将字符串解析成`DOM`树和`CSSOM`树
- 样式计算：得到`Computed Style`
- 布局：产生布局树
- 分层：划分图层
- 绘制：产生绘制指令集
- 分块：划分区域
- 光栅化：生成位图
- 画：生成`quad`，提交硬件，完成成像

## http缓存

浏览器将请求过的资源（html、js、css、img）等，根据缓存机制，拷贝一份副本存储在浏览器的内存或者磁盘上。 当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求

浏览器缓存主要分为**强缓存**（也称**本地缓存**）和**协商缓存**（也称**弱缓存**）。

### 强缓存

不向服务端发送请求，强制使用缓存数据，强缓存是利用http头中的`Expires`和`Cache-Control`两个字段来控制的 ，

当 ` cache-control`（约定过期时间的相对时间）和 `expires `（指定资源到期的时间）同时存在` cache-control` 的优先级会比 `expires `高

### 协商缓存

协商缓存是指当强缓存失效时，浏览器发送请求到服务器，通过与服务器进行协商来确定是否可以使用缓存的副本。 如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用。 

主要涉及到两组header字段：`Etag`和`If-None-Match`、`Last-Modified`和`if-modified-since`。 

服务器的` ETag` 和 浏览器的 `If-None-Match` 对应 

服务器的 `Last-Modified` 和 浏览器请求的` If-Modified-Since` 对应



Last-Modified 是服务器响应头中的字段，它表示资源的最后修改时间。当浏览器再次请求该资源时，会携带 If-Modified-Since 字段，将资源的最后修改时间发送给服务器。如果服务器判断该资源的最后修改时间与 If-Modified-Since 字段相同，则返回 304 Not Modified 状态码，告诉浏览器可以使用缓存的副本。

ETag 是服务器响应头中的字段，它是一个唯一标识符，表示资源的版本号。当浏览器再次请求该资源时，会携带 If-None-Match 字段，将资源的 ETag 值发送给服务器。如果服务器判断该资源的 ETag 值与 If-None-Match 字段相同，则返回 304 Not Modified 状态码，告诉浏览器可以使用缓存的副本。


### 缓存流程

![缓存流程](../../../../../%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A0%94%E4%BA%8C%E4%B8%8B/%E6%89%BE%E5%B7%A5%E4%BD%9C/%E5%89%8D%E7%AB%AF/assets/hclc.74fe02d1.png)



## 301、302状态码

301 永久重定向、302临时重定向

- 使用 302 或 307 取决于应用场景和开发者的需求。如果希望在重定向时保留原始请求的方法和消息体，可以使用 307；302可能会在重定向后的请求中把 POST 方法改为 GET 方法 。
- 303 是明确要求客户端使用 GET 方法的重定向，不管原请求是什么方法，重定向请求的方法都是 GET 。



## es6的新特性

- **let 和 const**：用于变量声明，提供块级作用域。
- **箭头函数（Arrow Functions）** ：简化了函数表达式的写法，使用 `=>` 符号
- **类（Classes）** ：引入了基于类的面向对象编程语法。
- **模板字符串（Template Literals）** ：允许嵌入表达式的字符串字面量。
- **默认参数值**：允许函数参数有默认值。
- **解构赋值（Destructuring Assignment）** ：允许从数组或对象中提取数据并赋值给变量。
- **扩展运算符（Spread Operator）和剩余参数（Rest Parameters）** ：使用 `...` 实现。
- **模块导入和导出（Modules）** ：使用 `import` 和 `export` 语法。
- **Promise 对象**：用于异步编程。
- **新的数据结构**：如 `Map`, `Set`, `WeakMap`, `WeakSet`
- **Symbol 类型**：引入了新的原始数据类型 `Symbol`，可用作唯一的属性键。
- **新的静态方法和属性**：例如 `Array.from`, `Object.assign`, `Number.isFinite`, `Math.trunc` 等

## 哪些是可迭代对象

可迭代对象（Iterable）是具有迭代行为的对象，可迭代对象可以通过 `for...of` 循环  。  数组、字符串、Map、Set是最常见的可迭代对象。 

可迭代对象是一种实现了迭代器协议（Iterator Protocol）的对象。迭代器协议包括一个名为 `Symbol.iterator` 的方法，该方法返回一个迭代器对象。 

## promise

promise 是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，以进行异步处理

有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱

### 三种状态

promise代表一个异步状态，有三个状态**pending（进行中），Resolve(已完成），Reject（失败）**

一旦状态改变，就不会在变。状态的改变只能通过`resolve、reject`来实现，从进行中变为已完成或者失败

### 方法

`Promise.race()` 和 `Promise.all()` 用于处理多个 Promise 实例的情况。 promise.all()是里面状态都改变，那就会输出，得到一个数组，promise.race() 里面只有一个状态变为rejected或者fulfilled即输出，

`then()` 方法用于注册当 Promise 对象的状态变为 resolved（成功）时的回调函数 ，`catch()` 方法用于注册当 Promise 对象的状态变为 rejected（失败）时的回调函数。 `finally()` 方法用于注册当 Promise 对象无论状态如何都要执行的回调函数。 

### 缺点

promise通常用来解决回调地狱的问题，但也有几个**不可忽视的缺点**

- promise一旦新建就会立即执行，无法中途取消

  当处于pending状态时，无法得知当前处于哪一个状态，是刚刚开始还是刚刚结束

  如果不设置回调函数，promise内部的错误就无法反映到外部

  promise封装ajax时，由于promise是异步任务，发送请求的三步会被延后到整个脚本同步代码执行完，并且将响应回调函数延迟到现有队列的最后，如果大量使用会大大降低了请求效率。

## react合成事件

React合成事件是React提供的一种事件处理机制，它抽象了浏览器原生事件，提供了一些额外的特性和优化。 

在React17之前，React是把事件委托在document上的，React17及以后版本不再把事件委托在document上，而是委托在挂载的容器上了 

React合成事件的主要特点包括：

1. 与原生事件兼容：React合成事件模拟了大部分浏览器原生事件的接口和行为，因此可以直接替换掉原生事件处理函数。
2. 跨平台支持：React合成事件可以在不同平台上使用相同的代码，无需考虑浏览器兼容性问题。
3. 事件委托：React合成事件采用了事件委托的方式处理事件，减少了事件监听器的数量，提高了性能。
4. 自动化内存管理：React合成事件会在组件卸载时自动销毁相关的事件监听器，避免了内存泄漏问题。 

React合成事件的具体实现方式包括：

1. 将所有事件绑定到document上，通过事件冒泡的方式传递到目标元素。(*事件委托机制冒泡到 root(react 17) 或者 document(react 16)*)
2. 将原生事件封装成合成事件，添加一些额外的属性和方法（如`stopPropagation()`、`preventDefault()`等）。
3. 将合成事件传递给组件的事件处理函数中，在处理函数中可以直接访问到合成事件对象，而无需关心浏览器兼容性问题。

 

作者：懒懒de开心
链接：https://juejin.cn/post/7229323314975998010 

## useEffect，具体传入的参数有哪些，有什么作用

#### useEffect

`useEffect` 是 React 中的一个 Hook，用于在函数组件中执行副作用操作。副作用操作指的是在组件中执行一些可能产生影响的操作，比如数据获取、订阅事件、手动操作 DOM 等。

`useEffect` 可以让你在函数组件中执行副作用操作，并且可以在组件的生命周期中控制副作用操作的执行时机。

`useEffect` 接受两个参数：

1. 第一个参数是一个回调函数，用于执行副作用操作。
2. 第二个参数是一个依赖数组（可选），用于控制副作用操作的触发条件。

当组件渲染完成后，React 会在浏览器绘制完成之后调用 `useEffect` 中传入的回调函数。如果传入了依赖数组，则 React 会在组件重新渲染后比较依赖项，只有当依赖项发生变化时，才会重新调用副作用函数。如果没有传入依赖数组，则副作用函数在每次组件渲染完成后都会执行。



## 如果想在请求到一个数据之后立刻使用这个数据要怎么做



## 有自己配过ESLint和ESCommit的东西吗



## 网络请求相关的调试工具



## 一个事件循环的输出题



## 到岗位时间 出勤天数等



# 补充

公司的了解



VUE生命周期函数



## VUE的响应式原理

https://cn.vuejs.org/guide/extras/reactivity-in-depth.html#reactivity-in-depth

### VUE2 响应式原理

当你把一个普通的 JavaScript 对象传入 Vue 实例作为 `data` 选项，Vue 将遍历此对象所有的 property，并使用 [`Object.defineProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些 property 全部转为 [getter/setter](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects#%E5%AE%9A%E4%B9%89_getters_%E4%B8%8E_setters) 

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。 

**每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。** 

![data](assets/data.png) 

由于 JavaScript 的限制，Vue **不能检测**数组和对象的变化。 

对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 `Vue.set(object, propertyName, value)` 方法向嵌套对象添加响应式 property。 

```
Vue.set(vm.someObject, 'b', 2) 

this.$set(this.someObject,'b',2) 

```

还可以使用Object.assign() 

Vue 不能检测以下数组的变动：

1. 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
2. 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一类问题，以下两种方式都可以实现和 `vm.items[indexOfItem] = newValue` 相同的效果，同时也将在响应式系统内触发状态更新：

```
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```

为了解决第二类问题，你可以使用 `splice`：

```
vm.items.splice(newLength)
```

### VUE3响应式原理

`vue2`中采用 `defineProperty`来劫持整个对象，然后进行深度遍历所有属性，给`每个属性`添加`getter和setter`，实现响应式。`vue3`采用`proxy`重写了响应式系统，因为`proxy`可以对`整个对象进行监听`，所以不需要深度遍历。



## 表单校验

`Form` 组件提供了表单验证的功能，只需为 `rules` 属性传入约定的验证规则，并将 `form-Item` 的 `prop` 属性设置为需要验证的特殊键值即可。 

## 设计模式 

 

面试内容：

 * 自我介绍 
 * 业务和技术平衡 
 * 就业看准的点
 * haproxy 
 * 实习介绍
 * 如何看待本岗位的工作内容 
 * 短期计划
 * 对公司的了解
 * 自己的优势
 * 自己的缺点
 * 相比于其他同学的亮点  



作者：赛文X 链接：<https://www.nowcoder.com/feed/main/detail/c64aaf2a21eb4f6cb5a8fdf46a466c59?sourceSSR=enterprise> 来源：牛客网 

 