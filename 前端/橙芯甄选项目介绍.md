项目技术

项目功能介绍：



### 1 项目前端技术

+ vue3框架：采用vue框架最新版本，组合式API形式开发项目

+ element-plus：UI组件库

+ vite：构建化工具

+ axios：网络交互

+ vue-router：采用vue-router最新版本管理路由

+ echarts: 数据可视化大屏

+ TypeScript：TypeScript技术栈

+ pinia: 集中式管理状态

  

### 2 项目功能介绍

- 首页
- 权限管理页面
  - 用户管理
  - 角色管理
  - 菜单管理
- 商品管理
    - 品牌管理
    - 属性管理
    - SPU管理
    - SKU管理

### 3 项目技术亮点

+ 规范化开发项目(eslint、prettier、stylelint、husky、commitlin、统一包管理器）
+ 封装后台管理系统模板
+ 菜单权限与按钮权限
+ 数据大屏
+ 请求响应拦截器二次封装
+ svg矢量图，主题颜色切换，暗黑模式



### 4 页面实现

#### 后端接口请求

1. 域名服务器配置

   ![1710499480704](assets/1710499480704.png)

2. vite.config.ts 代理跨域

   ```
   import { loadEnv } from 'vite'
   //....
   export default defineConfig(({ command, mode }) => {
     //获取各种环境下的对应的变量
     let env = loadEnv(mode, process.cwd())
     return {
       //代理跨域 省略其他
       server: {
         proxy: {
           [env.VITE_APP_BASE_API]: {
             //获取数据服务器地址的设置
             target: env.VITE_SERVE,
             //需要代理跨域
             changeOrigin: true,
             //路径重写
             rewrite: (path) => path.replace(/^\/api/, ''),
           },
         },
       },
     }
   })
   
   ```

3. api请求数据:示例

   ```
   // (src\api\user\index.ts )
   //统一管理项目用户相关的接口
   import request from '@/utils/request'
   
   //项目用户相关的请求地址
   enum API {
     LOGIN_URL = '/admin/acl/index/login',
     USERINFO_URL = '/admin/acl/index/info',
     LOGOUT_URL = '/admin/acl/index/logout',
   }
   //对外暴露请求函数
   //登录接口方法
   export const reqLogin = (data: any) => {
     return request.post<any, any>(API.LOGIN_URL, data)
   }
   
   //获取用户信息接口方法
   export const reqUserInfo = () => {
     return request.get<any, any>(API.USERINFO_URL)
   }
   
   //退出登录
   export const reqLogout = () => {
     return request.post<any, any>(API.LOGOUT_URL)
   }
   
   ```

4. 接口调用:示例

   ```
   //引入接口
   import { reqLogin, reqUserInfo, reqLogout } from '@/api/user'
   // 使用
   ```

   



页面结构与功能点：

#### 1 登录

业务逻辑：

+ 通知仓库发起请求
+ 请求成功，则路由跳转(看路由中是否有参数，如果有则跳转到请求页面，否则跳转主页面)
+ 请求失败，提示失败信息

```js
const login =  () => {
  //点击登录按钮以后干什么
  //通知仓库发起请求
  //请求成功->路由跳转
  //请求失败->弹出登陆失败信息
}
```



仓库store初始化 ：

+ 安装pinia: `pnpm i pinia@2.0.34 `
+ 定义大仓库，并且引入
+ 定义用户相关的小仓库
+ 登录页面调用

```
//仓库大仓库
import { createPinia } from 'pinia'
//创建大仓库
const pinia = createPinia()
//对外暴露：入口文件需要安装仓库typescript
```

```
//main.ts引入仓库
import pinia from './store'
//安装仓库
app.use(pinia)
```

```
//创建用户相关的小仓库
import { defineStore } from 'pinia'
//引入接口
import { reqLogin } from '@/api/user'
//引入数据类型
import type { loginForm } from '@/api/user/type'
//创建用户小仓库
const useUserStore = defineStore('User', {
  //小仓库存储数据地方
  state: () => {
    return {
      token: localStorage.getItem('TOKEN'), //用户唯一标识token
    }
  },
  //处理异步|逻辑地方
  actions: {
    //用户登录的方法
    async userLogin(data: loginForm) {
      //登录请求
      const result: any = await reqLogin(data)
      if (result.code == 200) {
        //pinia仓库存储token
        //由于pinia|vuex存储数据其实利用js对象
        this.token = result.data.token
        //本地存储持久化存储一份
        localStorage.setItem('TOKEN', result.data.token)
        //保证当前async函数返回一个成功的promise函数
        return 'ok'
      } else {
        return Promise.reject(new Error(result.data.message))
      }
    },
  },
  getters: {},
})
//对外暴露小仓库
export default useUserStore

```

```
//引入用户相关的小仓库
import useUserStore from "@/store/modules/user";

//登录按钮回调
const login = async () => {
  //保证全部表单相校验通过再发请求
  await loginForms.value.validate();
  //加载效果:开始加载
  loading.value = true;
  //点击登录按钮以后干什么?
  //通知仓库发登录请求
  //请求成功->首页展示数据的地方
  //请求失败->弹出登录失败信息
  try {
    //保证登录成功
    await useStore.userLogin(loginForm);
    //编程式导航跳转到展示数据首页
    //判断登录的时候,路由路径当中是否有query参数，如果有就往query参数挑战，没有跳转到首页
    let redirect: any = $route.query.redirect;
    $router.push({ path: redirect || '/' });
    //登录成功提示信息
    ElNotification({
      type: 'success',
      message: '欢迎回来',
      title: `HI,${getTime()}好`
    });
    //登录成功加载效果也消失
    loading.value = false;
  } catch (error) {
    //登录失败加载效果消息
    loading.value = false;
    //登录失败的提示信息
    ElNotification({
      type: 'error',
      message: (error as Error).message
    })
  }
}
```



#### 2 注册



#### 3 首页

+ 集成sass 环境

配置sass全局变量 : src\styles\variable.scss 

```
//左侧菜单宽度
$base-menu-width :260px;
//左侧菜单背景颜色
$base-menu-background: #001529;

//顶部导航的高度
$base-tabbar-height:50px;
```

主界面的静态页面结构

```
<!-- 结构 -->
<template>
  <div class="layout_container">
    <!-- 左侧菜单 -->
    <div class="layout_slider"></div>
    <!-- 顶部导航 -->
    <div class="layout_tabbar"></div>
    <!-- 内容展示区域 -->
    <div class="layout_main">
      <p style="height: 1000000px"></p>
    </div>
  </div>
</template>

<script setup lang="ts"></script>

<style lang="scss" scoped>
.layout_container {
  width: 100%;
  height: 100vh;
  .layout_slider {
    width: $base-menu-width;
    height: 100vh;
    background: $base-menu-background;
  }
  .layout_tabbar {
    position: fixed;
    width: calc(100% - $base-menu-width);
    height: $base-tabbar-height;
    background: cyan;
    top: 0;
    left: $base-menu-width;
  }
  .layout_main {
    position: absolute;
    width: calc(100% - $base-menu-width);
    height: calc(100vh - $base-tabbar-height);
    background-color: yellowgreen;
    left: $base-menu-width;
    top: $base-tabbar-height;
    padding: 20px;
    overflow: auto;
  }
}
</style>

```

##### 3.1 左侧菜单

![1710476496617](assets/1710476496617.png)



+ 添加配置文件
+ 封装logo组件
+ 递归生成动态菜单

```
//src\setting.ts 用于项目logo|标题配置
export default {
  title: '硅谷甄选运营平台', //项目的标题
  logo: '/public/logo.png', //项目logo设置
  logoHidden: true, //logo组件是否隐藏
}

```

###### 3.1.1ogo组件

```
<template>
  <div class="logo" v-if="setting.logoHidden">
    <img :src="setting.logo" alt="" />
    <p>{{ setting.title }}</p>
  </div>
</template>

<script setup lang="ts">
  //引入设置标题与logo配置文件
  import setting from '@/setting'
</script>

<style lang="scss" scoped>
  .logo {
    width: 100%;
    height: $base-menu-logo-height;
    color: white;
    display: flex;
    align-items: center;
    padding: 20px;
    img {
      width: 40px;
      height: 40px;
    }
    p {
      font-size: $base-logo-title-fontSize;
      margin-left: 10px;
    }
  }
</style>

```

###### 3.1.2递归路由组件生成动态路由菜单

+ 给路由加入元信息

  ```
  // 示例
  export const constantRoute = [
    {
      //登录
      path: '/login',
      component: () => import('@/views/login/index.vue'),
      name: 'login',
      meta: {
        title: '登录', //菜单标题
        hidden: true, //代表路由标题在菜单中是否隐藏  true:隐藏 false:不隐藏
        icon: 'Promotion', //菜单文字左侧的图标,支持element-plus全部图标
      },
    },
    {
      //登录成功以后展示数据的路由
      path: '/',
      component: () => import('@/layout/index.vue'),
      name: 'layout',
      meta: {
        title: '',
        hidden: false,
        icon: '',
      },
      redirect: '/home',
      children: [
        {
          path: '/home',
          component: () => import('@/views/home/index.vue'),
          meta: {
            title: '首页',
            hidden: false,
            icon: 'HomeFilled',
          },
        },
      ],
    },
    {
      //404
      path: '/404',
      component: () => import('@/views/404/index.vue'),
      name: '404',
      meta: {
        title: '404',
        hidden: true,
        icon: 'DocumentDelete',
      },
    },
    {
      path: '/screen',
      component: () => import('@/views/screen/index.vue'),
      name: 'Screen',
      meta: {
        hidden: false,
        title: '数据大屏',
        icon: 'Platform',
      },
    },
  ]
  ```

+ 仓库引入路由并对路由信息类型声明 

  ```
  //引入路由（常量路由）
  import { constantRoute } from '@/router/routes'
  // ....省略其他细节
  //小仓库存储数据地方
  state: (): UserState => {
    return {
      token: GET_TOKEN(), //用户唯一标识token
      menuRoutes: constantRoute, //仓库存储生成菜单需要数组（路由）
  }
  
  ```

+ layout 父组件拿到信息,传递给Menu子组件

  ```
   <Menu :menuList="userStore.menuRoutes"></Menu>
  
  <script setup lang="ts">
  // 省略其他细节
  //引入菜单组件
  import Menu from './menu/index.vue'
  //获取用户相关的小仓库
  import useUserStore from '@/store/modules/user'
  let userStore = useUserStore()
  </script>
  ```

+ Menu子组件分析处理数据

  ```
  <template>
    <template v-for="(item, index) in menuList" :key="item.path">
      <!-- 没有子路由 -->
      <template v-if="!item.children">
        <el-menu-item v-if="!item.meta.hidden" :index="item.path">
          <template #title>
            <span>图标</span>
            <span>{{ item.meta.title }}</span>
          </template>
        </el-menu-item>
      </template>
      <!-- 有且只有一个子路由 -->
      <template v-if="item.children && item.children.length == 1">
        <el-menu-item
          index="item.children[0].path"
          v-if="!item.children[0].meta.hidden"
        >
          <template #title>
            <span>图标</span>
            <span>{{ item.children[0].meta.title }}</span>
          </template>
        </el-menu-item>
      </template>
      <!-- 有子路由且个数大于一个 -->
      <el-sub-menu
        :index="item.path"
        v-if="item.children && item.children.length >= 2"
      >
        <template #title>
          <span>{{ item.meta.title }}</span>
        </template>
        <Menu :menuList="item.children"></Menu>
      </el-sub-menu>
    </template>
  </template>
  
  <script setup lang="ts">
  //获取父组件传递过来的全部路由数组
  defineProps(['menuList'])
  </script>
  <script lang="ts">
  export default {
    name: 'Menu',
  }
  </script>
  <style lang="scss" scoped></style>
  
  ```

+ 菜单图标

  + 注册element图标为全局组件

    ```
    //....
    //引入element-plus提供全部图标组件
    import * as ElementPlusIconsVue from '@element-plus/icons-vue'
    //......
    
    //对外暴露插件对象
    export default {
      //务必叫做install方法
      install(app: any) {
        //...
        //将element-plus提供图标注册为全局组件
        for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
          app.component(key, component)
        }
      },
    }
    
    ```

  + 给路由元信息添加属性：**icon**

  + 菜单组件使用

    之前`<span>图标</span>`处引入图标组件,示例如下:

    ```
     <el-icon>
            <component :is="item.children[0].meta.icon"></component>
     </el-icon>
    ```

    



##### 3.2 顶部导航

![1710495558778](assets/1710495558778.png)

左侧面包屑和右侧设置分成两个组件

###### 3.2.1 菜单折叠功能实现

1: 定义变量(src/store/modules/setting.ts )

```
//添加setting小仓库：layout组件相关配置仓库
import { defineStore } from 'pinia'

let useLayOutSettingStore = defineStore('SettingStore', {
  state: () => {
    return {
      fold: false, //用户控制菜单折叠还是收起的控制
    }
  },
})

export default useLayOutSettingStore

```

2: 在面包屑组件中切换变量值

```
<template>
  <!-- 顶部左侧的图标 -->
  <el-icon style="margin-right: 10px" @click="changeIcon">
    <component :is="LayOutSettingStore.fold ? 'Fold' : 'Expand'"></component>
  </el-icon>
  。。。。。。。
</template>

<script setup lang="ts">
import useLayOutSettingStore from '@/store/modules/setting'
//获取layout配置相关的仓库
let LayOutSettingStore = useLayOutSettingStore()

//点击图标的切换
const changeIcon = () => {
  //图标进行切换
  LayOutSettingStore.fold = !LayOutSettingStore.fold
}
</script>
。。。。。。

```

3: 在layout组件中依据fold变量的值切换左侧菜单的样式

![1710496186074](assets/1710496186074.png)

###### 3.2.2 顶部面包屑动态展示

在该组件中使用了$route.matched函数，此函数能得到当前路由的信息 

![1710496369701](assets/1710496369701.png)

**注意**: 访问首页时，因为它是二级路由，会遍历出layout面包屑，处理：删除layout路由的title。需要v-show 判断 

**注意**：:to ="item.path"将路由中的一级路由**权限管理**以及**商品管理**重定向到第一个孩子，这样点击跳转的时候会定向到第一个孩子。 

###### 3.2.3 刷新按钮的视线

1. 使用pinia定义一个变量作为标记,在之前的src/store/modules/setting.ts 中添加一个refresh变量

2. 在右侧设置组件(src\layout\tabbar\setting\index.vue )中修改refresh的值

   ```
   <script setup lang="ts">
   //使用layout的小仓库
   import useLayOutSettingStore from '@/store/modules/setting'
   let layoutSettingStore = useLayOutSettingStore()
   //刷新按钮点击的回调
   const updateRefresh = () => {
     layoutSettingStore.refresh = !layoutSettingStore.refresh
   }
   </script>
   ```

3. main组件检测标记销毁&重加载组件（**nextTick** )

   ![1710497032970](assets/1710497032970.png)

###### 3.2.4 全屏按钮实现

全屏按钮的实现函数

```
//全屏按钮点击的回调
const fullScreen = () => {
  //DOM对象的一个属性：可以用来判断当前是不是全屏的模式【全屏：true，不是全屏：false】
  let full = document.fullscreenElement
  //切换成全屏
  if (!full) {
    //文档根节点的方法requestFullscreen实现全屏
    document.documentElement.requestFullscreen()
  } else {
    //退出全屏
    document.exitFullscreen()
  }
```

###### 3.2.5 退出登录

1: 用户仓库中定义退出登录的函数

```
    //退出登录
    userLogout() {
      //当前没有mock接口（不做）：服务器数据token失效
      //本地数据清空
      this.token = ''
      this.username = ''
      this.avatar = ''
      REMOVE_TOKEN()
    },
```

2: 退出登录按钮函数

```
//退出登录点击回调
const logout = async () => {
    //第一件事情:需要向服务器发请求[退出登录接口]******
    //第二件事情:仓库当中关于用于相关的数据清空[token|username|avatar]
    //第三件事情:跳转到登录页面
    await userStore.userLogout();
    //跳转到登录页面
    $router.push({ path: '/login', query: { redirect: $route.path } });

}
```

注意:携带的query参数方便下次登陆时直接跳转到当时推出的界面 



##### 3.3 内容展示区



##### 3.4 home页面

1: request.ts 中为request对象添加请求拦截器

![1710497032970](assets/1710497836768.png)

2: user仓库中添加用户信息和获取信息的函数

![1710498117842](assets/1710498117842.png)

3: home页面引入并使用

![1710498214820](assets/1710498214820.png)



##### 3.6 路由守卫

###### 进度条

1. 安装` pnpm i nprogress `

2. src\permisstion.ts  中使用

```
//路由鉴权：鉴权：项目当中路由能不能被访问的权限
import router from '@/router'
import nprogress from 'nprogress'
//引入进度条样式
import 'nprogress/nprogress.css'
//全局前置守卫
router.beforeEach((to: any, from: any, next: any) => {
  //访问某一个路由之前的守卫
  nprogress.start()
  next()
})

//全局后置守卫
router.afterEach((to: any, from: any) => {
  // to and from are both route objects.
  nprogress.done()
})

//第一个问题：任意路由切换实现进度条业务 ----nprogress

```

3. main.ts 中使用 

```
//引入路由鉴权文件
import './permisstion'
```



###### 路由鉴权

```
//路由鉴权：鉴权：项目当中路由能不能被访问的权限
import router from '@/router'
import setting from './setting'
import nprogress from 'nprogress'
//引入进度条样式
import 'nprogress/nprogress.css'
//进度条的加载圆圈不要
nprogress.configure({ showSpinner: false })
//获取用户相关的小仓库内部token数据，去判断用户是否登陆成功
import useUserStore from './store/modules/user'
//为什么要引pinia
import pinia from './store'
const userStore = useUserStore(pinia)

//全局前置守卫
router.beforeEach(async (to: any, from: any, next: any) => {
  //网页的名字
  document.title = `${setting.title}-${to.meta.title}`
  //访问某一个路由之前的守卫
  nprogress.start()
  //获取token，去判断用户登录、还是未登录
  const token = userStore.token
  //获取用户名字
  let username = userStore.username
  //用户登录判断
  if (token) {
    //登陆成功，访问login。指向首页
    if (to.path == '/login') {
      next('/home')
    } else {
      //登陆成功访问其余的，放行
      //有用户信息
      if (username) {
        //放行
        next()
      } else {
        //如果没有用户信息，在收尾这里发请求获取到了用户信息再放行
        try {
          //获取用户信息
          await userStore.userInfo()
          next()
        } catch (error) {
          //token过期|用户手动处理token
          //退出登陆->用户相关的数据清空
          userStore.userLogout()
          next({ path: '/login', query: { redirect: to.path } })
        }
      }
    }
  } else {
    //用户未登录
    if (to.path == '/login') {
      next()
    } else {
      next({ path: '/login', query: { redirect: to.path } })
    }
  }
  next()
})

//全局后置守卫
router.afterEach((to: any, from: any) => {
  // to and from are both route objects.
  nprogress.done()
})

//第一个问题：任意路由切换实现进度条业务 ----nprogress
//第二个问题：路由鉴权
//全部路由组件 ：登录|404|任意路由|首页|数据大屏|权限管理（三个子路由）|商品管理（4个子路由）

//用户未登录 ：可以访问login 其余都不行
//登陆成功：不可以访问login 其余都可以

```



#### 4 权限管理页面

##### 4.1 用户管理

利用[TS 封装 Axios](https://juejin.cn/post/7154991998989959181)



##### 4.2 角色管理



##### 4.3 菜单管理

![1710503886432](assets/1710503886432.png)





#### 5 商品管理

##### 5.1 品牌管理



##### 5.2 属性管理



##### 5.3 SPU管理



##### 5.4 SKU管理



